#ifndef __QBE_WORLD_HPP__
#define __QBE_WORLD_HPP__

struct vec;
struct dynent;

enum          // block types, order matters!
{
  SOLID = 0,  // entirely solid cube [only specifies wtex]
  CORNER,     // half full corner of a wall
  FHF,        // floor heightfield using neighbour vdelta values
  CHF,        // idem ceiling
  SPACE,      // entirely empty cube
  SEMISOLID,  // generated by mipmapping
  MAXTYPE
};

struct sqr
{
  uchar type;                 // one of the above
  char floor, ceil;           // height, in cubes
  uchar wtex, ftex, ctex;     // wall/floor/ceil texture ids
  uchar r, g, b;              // light value at upper left vertex
  uchar vdelta;               // vertex delta, used for heightfield cubes
  char defer;                 // used in mipmapping, when true this cube is not a perfect mip
  char occluded;              // true when occluded
  uchar utex;                 // upper wall tex id
  uchar tag;                  // used by triggers
};

struct block
{
  int x, y, xs, ys;
};

enum                            // hardcoded texture numbers
{
  DEFAULT_SKY = 0,
  DEFAULT_LIQUID,
  DEFAULT_WALL,
  DEFAULT_FLOOR,
  DEFAULT_CEIL
};

extern sqr *map, *mmip[];          // map data, the mips are sequential 2D arrays in memory

namespace world
{

  void setup(int factor);
  /*! main empty world creation routine, if passed factor -1 will enlarge old
   *  world by 1
   */
  void empty(int factor, bool force);

  /*! Main geometric mipmapping routine, recursively rebuild
   *  mipmaps within block
   */
  void remip(block &b, int world = 0);
  /*! Same but also consider the neighbors */
  void remipmore(block &b, int world = 0);
  /*! Used for edit mode ent display */
  int closestent(void);
  int findentity(int type, int index = 0);
  /*! Trigger tag */
  void trigger(int tag, int type, bool savegame);
  /*! Reset for editing or map saving */
  void resettagareas(void);
  /*! Set for playing */
  void settagareas(void);
  /*! Create a new entity */
  entity *newentity(int x, int y, int z, char *what, int v1, int v2, int v3, int v4);
  /*! Update the lighting per vertex */
  void calclight(void);
  void dodynlight(vec &vold, vec &v, int reach, int strength, dynent *owner);
  void cleardlights(void);
  block *blockcopy(block &b);
  void blockpaste(block &b);
  /*! Save the world as .cgz file */
  void save(const char *fname);
  /*! Load the world from .cgz file */
  void load(const char *mname);
  void writemap(char *mname, int msize, uchar *mdata);
  uchar *readmap(const char *mname, int *msize);

  void render(float vx, float vy, float vh, int yaw, int pitch, float widef, int w, int h);

  /*! Constructs occlusion map */
  void computeraytable(float vx, float vy);
  /*! Test occlusion for a cube (v = viewer, c = cube to test) */
  int isoccluded(float vx, float vy, float cx, float cy, float csize);

} /* namespace world */

#endif /* __QBE_WORLD_HPP__ */

